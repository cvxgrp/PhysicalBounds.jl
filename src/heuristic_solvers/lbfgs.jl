export heuristic_solve, LBFGS

abstract type LBFGS end

# This uses LBFGS-B to solve the problem
# min   -f(z)             min    -f(A⁻¹(θ)b)
# s.t.  A(θ)z = b   ⟺   s.t.    0 ≤ θ ≤ 1
#       0 ≤ θ ≤ 1
# where we assume that A(θ) is invertible
@doc raw"""
    function heuristic_solve(
        ::Type{LBFGS}, 
        physics::IntegralEquation, 
        c_complex;
        θ₀=nothing,
        λ=0,
        rseed=0,
        m=20,
        factr=1e7,
        pgtol=1e-8,
        iprint=1,
        maxfun=1000,
        maxiter=250
    )

Uses LBFGS-B to solve the physical design problem
```math
\begin{aligned}
&& \text{minimize} &-f(z) \\
&& \text{subject to} & A(\theta)z = b \\
&&& 0 \le \theta \le 1.
\end{aligned}
```
The equality constraint is eliminated by substituting $A(\theta)^{-1}b$ for $z$.
The objective $f$ is
```math
f(z) = \frac{\lvert c^Tz\rvert}{\|z\|^2} + \lambda\lvert c^Tz\rvert.
```
Note that if we set $\lambda = 0$, we are optimizing for 'purity', whereas if
we set $\lambda = \infty$, we are optimizing for power (in a particular mode).

The solver warmstarts at `θ₀`. The LBFGSB solver has parameters 
`m`, `factr`, `pgtol`, `iprint`, `maxfun`, and `maxiter`. See code for details.
"""
function heuristic_solve(
    ::Type{LBFGS}, 
    physics::IntegralEquation, 
    c_complex;
    θ₀=nothing,
    λ=0,
    rseed=0,
    m=20,
    factr=1e7,
    pgtol=1e-8,
    iprint=1,
    maxfun=1000,
    maxiter=250
)
    # LBFGS parameters
    # - m: the maximum number of variable metric corrections used to define the limited memory matrix
    # - factr: the iteration will stop when (f^k - f^{k+1})/max{|f^k|,|f^{k+1}|,1} <= factr*epsmch,
    #     where epsmch is the machine precision, which is automatically generated by the code. Typical values for factr:
    #     1e12 for low accuracy, 1e7 for moderate accuracy, 1e1 for extremely high accuracy
    # - pgtol: the iteration will stop when max{|proj g_i | i = 1, ..., n} <= pgtol where pg_i is the ith component of the projected gradient
    # - iprint: controls the frequency of output. iprint < 0 means no output:
    #     iprint = 0 print only one line at the last iteration
    #     0 < iprint < 99 print also f and |proj g| every iprint iterations
    #     iprint = 99 print details of every iteration except n-vectors
    #     iprint = 100 print also the changes of active set and final x
    #     iprint > 100 print details of every iteration including x and g
    # - maxfun: the maximum number of function evaluations
    # - maxiter: the maximum number of iterations
    n = length(physics.b_design)
    Gd = to_real(physics.G_design)
    Gt = to_real(physics.G_target)
    bd = to_real(physics.b_design)
    bt = to_real(physics.b_target)
    c = eltype(c_complex) <: Int ? c_complex : to_real(c_complex)

    θprev = zeros(n)
    # cache = (
    #     Aθ=zeros(2n, 2n),
    #     y=zeros(2n),
    #     z=zeros(2n),
    #     x=zeros(2n)
    # )

    # g(y) = ||c^† * (bt - Gt*y)||^2 / ||(bt - Gt*y)||^2
    # x(y) = bt - Gt * y
    # g(x) = ||c^†x||^2 / ||x||^2
    # g(x) = a(x) / b(x) ⟹ g'(x) = ∇a(x) / b(x) + a(x) / b(x)^2 * -1 * ∇b(x)
    function dgdy(Gt, x, c, λ)
        nt = length(x) ÷ 2
        xr = @view(x[1:nt])
        xi = @view(x[nt+1:end])

        if eltype(c) <: Int
            a = norm(xr[c])^2 + norm(xi[c])^2
            ∂a = zeros(1, 2nt)
            ∂a[1, c] .= 2*xr[c]
            ∂a[1, nt.+c] .= 2*xi[c]
        else
            cr = @view(c[1:nt])
            ci = @view(c[nt+1:end])
            C = [cr*cr' + ci*ci'    cr*ci' - ci*cr'; 
                -cr*ci' + ci*cr'   cr*cr' + ci*ci']

            a = (dot(cr, xr) + dot(ci, xi))^2 + (-dot(ci, xr) + dot(cr, xi))^2
            ∂a = 2 * x' * C
        end
            
        b = sum(x->x^2, x)
        ∂b = 2 * x'
        if isinf(λ)
            # Scaling since objective is teeny tiny
            return ∂a * Gt * 1e5
        elseif iszero(λ)
            return (@. ∂a / b - a/b^2 * ∂b) * Gt
        else
            return (@. ∂a / b - a/b^2 * ∂b) * Gt + λ * ∂a * Gt
        end
    end

    # y(θ) = z(θ) .* θ
    function dydθ(θ, z, dzdθ)
        n = length(z) ÷ 2
        return [Diagonal(z[1:n]); Diagonal(z[n+1:2n])] + Diagonal([θ; θ]) * dzdθ
    end

    # Aθ should be factorized
    function dzdθ(Aθ, Gd, z)
        n = length(z) ÷ 2
        Gz = Gd * Diagonal(z)             # Ai * z = gi*eiᵀ*z = gi*zi
        Gz = Gz[:,1:n] + Gz[:,n+1:end]
        return - Aθ \ Gz
    end

    function g!(∇f, θ, Gd, Gt, bd, bt, c, λ)
        n = length(θ)
        Aθ = Diagonal(ones(2n)) + Gd * Diagonal([θ; θ])
        z = Aθ \ bd
        y = [θ; θ] .* z
        x = bt + Gt * y
        ∇f .= -(dgdy(Gt, x, c, λ) * dydθ(θ, z, dzdθ(Aθ, Gd, z)) )[1:n]
        return nothing
    end


    function f(θ, Gd, Gt, bd, bt, c, λ)
        n = length(θ)
        nt = length(bt) ÷ 2 
        Aθ = Diagonal(ones(2n)) + Gd * Diagonal([θ; θ])
        z = Aθ \ bd
        y = [θ; θ] .* z
        x = bt + Gt * y
        
        xr = @view(x[1:nt])
        xi = @view(x[nt+1:end])

        if eltype(c) <: Int
            num = norm(xr[c])^2 + norm(xi[c])^2
        else
            cr = @view(c[1:nt])
            ci = @view(c[nt+1:end])
            
            num = (dot(cr, xr) + dot(ci, xi))^2 + (-dot(ci, xr) + dot(cr, xi))^2
        end
        denom = sum(x->abs(x)^2, x)
        # return -num
        if isinf(λ)
            # Scaling since objective is teeny tiny
            return -num * 1e5
        elseif iszero(λ)
            return -num / denom
        else
            return -num / denom - λ * num
        end
    end

    f(θ) = f(θ, Gd, Gt, bd, bt, c, λ)
    g!(∇f, θ) = g!(∇f, θ, Gd, Gt, bd, bt, c, λ)

    # LBFGSB uses the inputs
    # f(x), g!(z, x)
    # the first argument is the dimension of the largest problem to be solved
    # the second argument is the maximum number of limited memory correction
    optimizer = L_BFGS_B(n, m)
    if isnothing(θ₀)
        Random.seed!(rseed)
        θ₀ = rand(n)
    end
    # set up bounds (1 col = bounds for 1 var)
    #  row 1:   0->unbounded, 1->only lower bound, 2-> both lower and upper bounds, 3->only upper bound
    #  row 2:   the lower bound on x, of length n.
    #  row 3:   the upper bound on x, of length n.
    bounds = vcat(2*ones(1,n), zeros(1,n), ones(1,n))

    # call the optimizer
    fout, θout = optimizer(f, g!, θ₀, bounds; m, factr, pgtol, iprint, maxfun, maxiter)
    return fout, θout
end