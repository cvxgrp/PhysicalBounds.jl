<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API reference · PhysicalBounds.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://github.com/cvxgrp/PhysicalBounds.jl/api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">PhysicalBounds.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../examples/bend/">Bend design</a></li><li><a class="tocitem" href="../examples/lens/">Lens bounds and design</a></li><li><a class="tocitem" href="../examples/mode-converter/">Mode converter bounds and design</a></li></ul></li><li class="is-active"><a class="tocitem" href>API reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/main/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><ul><li><a href="#PhysicalBounds.build_COSMO_model_dual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T, S&lt;:(AbstractMatrix)}"><code>PhysicalBounds.build_COSMO_model_dual</code></a></li><li><a href="#PhysicalBounds.build_COSMO_model_primal-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T, S&lt;:(AbstractMatrix)}"><code>PhysicalBounds.build_COSMO_model_primal</code></a></li><li><a href="#PhysicalBounds.build_Hypatia_model_dual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T&lt;:Real, S&lt;:AbstractMatrix{T}}"><code>PhysicalBounds.build_Hypatia_model_dual</code></a></li><li><a href="#PhysicalBounds.build_Hypatia_model_primal-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T&lt;:Real, S&lt;:(AbstractMatrix)}"><code>PhysicalBounds.build_Hypatia_model_primal</code></a></li><li><a href="#PhysicalBounds.construct_matrices-Tuple{WaveOperators.IntegralEquation, Any}"><code>PhysicalBounds.construct_matrices</code></a></li><li><a href="#PhysicalBounds.dual_problem_solve-Tuple{Any, Any, Any}"><code>PhysicalBounds.dual_problem_solve</code></a></li><li><a href="#PhysicalBounds.heuristic_solve-Tuple{Type{LBFGS}, WaveOperators.IntegralEquation, Any}"><code>PhysicalBounds.heuristic_solve</code></a></li><li><a href="#PhysicalBounds.optimize-Union{Tuple{Hypatia.Models.Model{T}}, Tuple{T}} where T"><code>PhysicalBounds.optimize</code></a></li><li><a href="#PhysicalBounds.optimize!-Tuple{COSMO.Workspace}"><code>PhysicalBounds.optimize!</code></a></li><li><a href="#PhysicalBounds.primal_problem_solve-Tuple{Any, Any, Any}"><code>PhysicalBounds.primal_problem_solve</code></a></li><li><a href="#PhysicalBounds.to_complex"><code>PhysicalBounds.to_complex</code></a></li><li><a href="#PhysicalBounds.to_real"><code>PhysicalBounds.to_real</code></a></li><li><a href="#PhysicalBounds.unvec_symm-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number"><code>PhysicalBounds.unvec_symm</code></a></li><li><a href="#PhysicalBounds.unvec_symm-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>PhysicalBounds.unvec_symm</code></a></li><li><a href="#PhysicalBounds.unvec_symm_scs-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number"><code>PhysicalBounds.unvec_symm_scs</code></a></li><li><a href="#PhysicalBounds.vec_symm-Tuple{Any}"><code>PhysicalBounds.vec_symm</code></a></li><li><a href="#PhysicalBounds.vec_symm_scs-Tuple{Any}"><code>PhysicalBounds.vec_symm_scs</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.build_COSMO_model_dual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T, S&lt;:(AbstractMatrix)}" href="#PhysicalBounds.build_COSMO_model_dual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T, S&lt;:(AbstractMatrix)}"><code>PhysicalBounds.build_COSMO_model_dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_COSMO_model_dual(
    C::AbstractMatrix{T}, 
    A::Vector{S}, 
    b::AbstractVector{T};
    x0=nothing, 
    y0=nothing,
    tol=1e-4, 
    verbose=false
) where {T, S &lt;: Union{AbstractMatrix, AbstractSparseMatrix}}</code></pre><p>Given an SDP in LMI form</p><p class="math-container">\[\begin{aligned}
&amp; \text{minimize} &amp;&amp; b^Ty \\
&amp; \text{subject to} &amp;&amp; \sum_{i=1}^m y_iA_i + C \succeq 0 \\
\end{aligned}\]</p><p>builds and returns a COSMO model.</p><p>The model is warmstarted at primal-dual point <code>(x0, y0)</code> and set to have stopping tolerance <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/sdp_solvers/cosmo.jl#LL42-L64">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.build_COSMO_model_primal-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T, S&lt;:(AbstractMatrix)}" href="#PhysicalBounds.build_COSMO_model_primal-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T, S&lt;:(AbstractMatrix)}"><code>PhysicalBounds.build_COSMO_model_primal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_COSMO_model_primal(
    C::AbstractMatrix{T}, 
    A::Vector{S}, 
    b::AbstractVector{T};
    ineq=false,
    x0=nothing,
    y0=nothing,
    tol=1e-4,
    verbose=false
) where {T, S &lt;: Union{AbstractSparseMatrix, AbstractMatrix}}</code></pre><p>Given an SDP in standard form</p><p class="math-container">\[\begin{aligned}
&amp; \text{maximize} &amp;&amp; \mathbf{tr}(CX) \\
&amp; \text{subject to} &amp;&amp; \mathbf{tr}(A_iX) = b_i, \qquad i = 1, \dots, m \\
&amp;&amp;&amp; X \succeq 0,
\end{aligned}\]</p><p>builds and returns a COSMO model. If <code>ineq</code> is <code>true</code>, then the equality  constraints are transformed into inequality constraints <span>$\mathbf{tr}(A_iX) \le b$</span>.</p><p>The model is warmstarted at primal-dual point <code>(x0, y0)</code> and set to have stopping tolerance <code>tol</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/sdp_solvers/cosmo.jl#LL200-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.build_Hypatia_model_dual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T&lt;:Real, S&lt;:AbstractMatrix{T}}" href="#PhysicalBounds.build_Hypatia_model_dual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T&lt;:Real, S&lt;:AbstractMatrix{T}}"><code>PhysicalBounds.build_Hypatia_model_dual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_Hypatia_model_dual(
    C::AbstractMatrix{T},
    A::Vector{S},
    b::AbstractVector{T}
) where {T &lt;: Real, S &lt;: AbstractMatrix{T}}</code></pre><p>Given an SDP in LMI form</p><p class="math-container">\[\begin{aligned}
&amp; \text{minimize} &amp;&amp; b^Ty \\
&amp; \text{subject to} &amp;&amp; \sum_{i=1}^m y_iA_i + C \succeq 0 \\
\end{aligned}\]</p><p>builds and returns a Hypatia model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/sdp_solvers/hypatia.jl#LL56-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.build_Hypatia_model_primal-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T&lt;:Real, S&lt;:(AbstractMatrix)}" href="#PhysicalBounds.build_Hypatia_model_primal-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T&lt;:Real, S&lt;:(AbstractMatrix)}"><code>PhysicalBounds.build_Hypatia_model_primal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">build_Hypatia_model_primal(
    C::AbstractMatrix{T},
    A::Vector{S},
    b::AbstractVector{T}
) where {T &lt;: Real, S &lt;: Union{AbstractSparseMatrix, AbstractMatrix}}</code></pre><p>Given an SDP in standard form</p><p class="math-container">\[\begin{aligned}
&amp; \text{maximize} &amp;&amp; \mathbf{tr}(CX) \\
&amp; \text{subject to} &amp;&amp; \mathbf{tr}(A_iX) = b_i, \qquad i = 1, \dots, m \\
&amp;&amp;&amp; X \succeq 0,
\end{aligned}\]</p><p>builds and returns a Hypatia model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/sdp_solvers/hypatia.jl#LL9-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.construct_matrices-Tuple{WaveOperators.IntegralEquation, Any}" href="#PhysicalBounds.construct_matrices-Tuple{WaveOperators.IntegralEquation, Any}"><code>PhysicalBounds.construct_matrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contruct_matrices(physics::IntegralEquation, P::M, Q::M) where {M &lt;: AbstractMatrix}</code></pre><p>Constructs the matrices <span>$\bar P, \bar Q, \bar A_i$</span> as in <a href="https://arxiv.org/abs/2204.05243">[Angeris et al. 2021]</a> used to build the bounding semidefinite program.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/construct_sdp.jl#LL1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.dual_problem_solve-Tuple{Any, Any, Any}" href="#PhysicalBounds.dual_problem_solve-Tuple{Any, Any, Any}"><code>PhysicalBounds.dual_problem_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dual_problem_solve(C, Av, b; optimizer=Hypatia.Optimizer(verbose=false))</code></pre><p>Solves the &#39;dual&#39; SDP</p><p class="math-container">\[\begin{aligned}
&amp; \text{minimize} &amp;&amp; b^Ty \\
&amp; \text{subject to} &amp;&amp; \sum_{i=1}^m y_iA_i + C \succeq 0 \\
\end{aligned}\]</p><p>where the <span>$A_i$</span>&#39;s are stored in the vector <code>Av</code>, using the specified optimizer.</p><p>Returns the model and variable <span>$y$</span>, after running the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/sdp_solvers/jump_interface.jl#LL57-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.heuristic_solve-Tuple{Type{LBFGS}, WaveOperators.IntegralEquation, Any}" href="#PhysicalBounds.heuristic_solve-Tuple{Type{LBFGS}, WaveOperators.IntegralEquation, Any}"><code>PhysicalBounds.heuristic_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function heuristic_solve(
    ::Type{LBFGS}, 
    physics::IntegralEquation, 
    c_complex;
    θ₀=nothing,
    λ=0,
    rseed=0,
    m=20,
    factr=1e7,
    pgtol=1e-8,
    iprint=1,
    maxfun=1000,
    maxiter=250
)</code></pre><p>Uses L-BFGS-B to solve the physical design problem</p><p class="math-container">\[\begin{aligned}
&amp; \text{minimize} &amp;&amp;-f(z) \\
&amp; \text{subject to} &amp;&amp; A(\theta)z = b \\
&amp;&amp;&amp; 0 \le \theta \le 1.
\end{aligned}\]</p><p>The equality constraint is eliminated by substituting <span>$A(\theta)^{-1}b$</span> for <span>$z$</span>. The objective <span>$f$</span> is</p><p class="math-container">\[f(z) = \frac{\lvert c^Tz\rvert}{\|z\|^2} + \lambda\lvert c^Tz\rvert.\]</p><p>Note that if we set <span>$\lambda = 0$</span>, we are optimizing for &#39;purity&#39;, whereas if we set <span>$\lambda = \infty$</span>, we are optimizing for power (in a particular mode).</p><p>The solver warmstarts at <code>θ₀</code>. The L-BFGS-B solver has parameters  <code>m</code>, <code>factr</code>, <code>pgtol</code>, <code>iprint</code>, <code>maxfun</code>, and <code>maxiter</code>. See code for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/heuristic_solvers/lbfgs.jl#LL10-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.optimize!-Tuple{COSMO.Workspace}" href="#PhysicalBounds.optimize!-Tuple{COSMO.Workspace}"><code>PhysicalBounds.optimize!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize!(model::COSMO.Workspace) = COSMO.optimize!(model)</code></pre><p>Calls the COSMO solver on the problem <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/sdp_solvers/cosmo.jl#LL306-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.optimize-Union{Tuple{Hypatia.Models.Model{T}}, Tuple{T}} where T" href="#PhysicalBounds.optimize-Union{Tuple{Hypatia.Models.Model{T}}, Tuple{T}} where T"><code>PhysicalBounds.optimize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">optimize(model::Hypatia.Models.Model{T}; verbose=true) where {T}</code></pre><p>Calls the Hypatia solver on the problem <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/sdp_solvers/hypatia.jl#LL95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.primal_problem_solve-Tuple{Any, Any, Any}" href="#PhysicalBounds.primal_problem_solve-Tuple{Any, Any, Any}"><code>PhysicalBounds.primal_problem_solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">primal_problem_solve(C, Av, b; ineq = nothing, optimizer=Hypatia.Optimizer(verbose=false), warmstart_X=nothing)</code></pre><p>Solves the SDP</p><p class="math-container">\[\begin{aligned}
&amp; \text{minimize} &amp;&amp; \mathbf{tr}(CX) \\
&amp; \text{subject to} &amp;&amp; \mathbf{tr}(A_iX) = b_i, \qquad i = 1, \dots, m \\
&amp;&amp;&amp; X \succeq 0,
\end{aligned}\]</p><p>where the <span>$A_i$</span>&#39;s are stored in the vector <code>Av</code>, using the specified optimizer.</p><p>Returns the model and variable <span>$X$</span>, after running the solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/sdp_solvers/jump_interface.jl#LL1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.to_complex" href="#PhysicalBounds.to_complex"><code>PhysicalBounds.to_complex</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_complex(x)</code></pre><p>Returns a complex vector <code>y</code> corresponding to <code>x</code>, where <code>x</code> is assumed to have the form</p><p class="math-container">\[    x = \begin{bmatrix} \mathbf{Re}(y) \\ \mathbf{Im}(y) \end{bmatrix}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/tools.jl#LL22-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.to_real" href="#PhysicalBounds.to_real"><code>PhysicalBounds.to_real</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">to_real(x)</code></pre><p>Converts <code>x</code> to real.</p><p>If <code>x</code> is a <code>Vector</code><code>, returns the real and imaginary parts stacked:</code>[real(x)ᵀ imag(x)ᵀ]ᵀ`.</p><p>If <code>x</code> is a matrix, returns [real(x) -imag(x) ; imag(x) real(x)]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/tools.jl#LL1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.unvec_symm-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number" href="#PhysicalBounds.unvec_symm-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number"><code>PhysicalBounds.unvec_symm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unvec_symm(x, dim)</code></pre><p>Returns a dim-by-dim symmetric matrix corresponding to <code>x</code>. <code>x</code> is a vector of length dim*(dim + 1)/2, corresponding to a symmetric matrix</p><pre><code class="nohighlight hljs">X = [ X11  X12 ... X1k
      X21  X22 ... X2k
      ...
      Xk1  Xk2 ... Xkk ],</code></pre><p>where <code>vec(X) = (X11, X12, X22, X13, X23, ..., Xkk)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/construct_sdp.jl#LL135-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.unvec_symm-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number" href="#PhysicalBounds.unvec_symm-Union{Tuple{Vector{T}}, Tuple{T}} where T&lt;:Number"><code>PhysicalBounds.unvec_symm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unvec_symm(x)</code></pre><p>Returns a dim-by-dim symmetric matrix corresponding to vector <code>x</code>, where <code>dim</code>  is the unique positive solution to <code>dim * (dim + 1) ÷ 2 = length(x)</code>:</p><pre><code class="nohighlight hljs">X = [ X11  X12 ... X1k
      X21  X22 ... X2k
      ...
      Xk1  Xk2 ... Xkk ],</code></pre><p>where <code>vec(X) = (X11, X12, X22, X13, X23, ..., Xkk)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/construct_sdp.jl#LL159-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.unvec_symm_scs-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number" href="#PhysicalBounds.unvec_symm_scs-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:Number"><code>PhysicalBounds.unvec_symm_scs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unvec_symm_scs(x)</code></pre><p>Returns a dim-by-dim symmetric matrix corresponding to <code>x</code>. <code>x</code> is a vector of length dim*(dim + 1)/2, corresponding to a symmetric matrix</p><pre><code class="nohighlight hljs">X = [ X11     X12/√2 ... X1k/√2
      X21/√2  X22    ... X2k/√2
      ...
      Xk1/√2  Xk2/√2 ... Xkk ],</code></pre><p>where <code>vec(X) = (X11, X12, X22, X13, X23, ..., Xkk)</code></p><p>Note that the factor √2 preserves inner products: <code>x&#39;*c = Tr(unvec_symm(c, dim) * unvec_symm(x, dim))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/construct_sdp.jl#LL66-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.vec_symm-Tuple{Any}" href="#PhysicalBounds.vec_symm-Tuple{Any}"><code>PhysicalBounds.vec_symm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vec_symm(X)</code></pre><p>Returns a vectorized representation of a symmetric matrix <code>X</code>. <code>vec(X) = (X11, X12, X22, X13, X23, ..., Xkk)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/construct_sdp.jl#LL126-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PhysicalBounds.vec_symm_scs-Tuple{Any}" href="#PhysicalBounds.vec_symm_scs-Tuple{Any}"><code>PhysicalBounds.vec_symm_scs</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">vec_symm_scs(X)</code></pre><p>Returns a vectorized representation of a symmetric matrix <code>X</code>. <code>vec(X) = (X11, √2*X12, X22, √2*X13, X23, ..., Xkk)</code></p><p>Note that the factor √2 preserves inner products: <code>x&#39;*c = Tr(unvec_symm(c, dim) * unvec_symm(x, dim))</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/cvxgrp/PhysicalBounds.jl/blob/d93d9d5c84968312338fe6216a2664f8da9ddc09/src/construct_sdp.jl#LL106-L114">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/mode-converter/">« Mode converter bounds and design</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 14 April 2023 20:37">Friday 14 April 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
