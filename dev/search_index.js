var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API reference","title":"API Reference","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [PhysicalBounds]","category":"page"},{"location":"api/#PhysicalBounds.build_COSMO_model_dual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T, S<:(AbstractMatrix)}","page":"API reference","title":"PhysicalBounds.build_COSMO_model_dual","text":"build_COSMO_model_dual(\n    C::AbstractMatrix{T}, \n    A::Vector{S}, \n    b::AbstractVector{T};\n    x0=nothing, \n    y0=nothing,\n    tol=1e-4, \n    verbose=false\n) where {T, S <: Union{AbstractMatrix, AbstractSparseMatrix}}\n\nGiven an SDP in LMI form\n\nbeginaligned\n textminimize  b^Ty \n textsubject to  sum_i=1^m y_iA_i + C succeq 0 \nendaligned\n\nbuilds and returns a COSMO model.\n\nThe model is warmstarted at primal-dual point (x0, y0) and set to have stopping tolerance tol.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.build_COSMO_model_primal-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T, S<:(AbstractMatrix)}","page":"API reference","title":"PhysicalBounds.build_COSMO_model_primal","text":"build_COSMO_model_primal(\n    C::AbstractMatrix{T}, \n    A::Vector{S}, \n    b::AbstractVector{T};\n    ineq=false,\n    x0=nothing,\n    y0=nothing,\n    tol=1e-4,\n    verbose=false\n) where {T, S <: Union{AbstractSparseMatrix, AbstractMatrix}}\n\nGiven an SDP in standard form\n\nbeginaligned\n textmaximize  mathbftr(CX) \n textsubject to  mathbftr(A_iX) = b_i qquad i = 1 dots m \n X succeq 0\nendaligned\n\nbuilds and returns a COSMO model. If ineq is true, then the equality  constraints are transformed into inequality constraints mathbftr(A_iX) le b.\n\nThe model is warmstarted at primal-dual point (x0, y0) and set to have stopping tolerance tol.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.build_Hypatia_model_dual-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T<:Real, S<:AbstractMatrix{T}}","page":"API reference","title":"PhysicalBounds.build_Hypatia_model_dual","text":"build_Hypatia_model_dual(\n    C::AbstractMatrix{T},\n    A::Vector{S},\n    b::AbstractVector{T}\n) where {T <: Real, S <: AbstractMatrix{T}}\n\nGiven an SDP in LMI form\n\nbeginaligned\n textminimize  b^Ty \n textsubject to  sum_i=1^m y_iA_i + C succeq 0 \nendaligned\n\nbuilds and returns a Hypatia model.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.build_Hypatia_model_primal-Union{Tuple{S}, Tuple{T}, Tuple{AbstractMatrix{T}, Vector{S}, AbstractVector{T}}} where {T<:Real, S<:(AbstractMatrix)}","page":"API reference","title":"PhysicalBounds.build_Hypatia_model_primal","text":"build_Hypatia_model_primal(\n    C::AbstractMatrix{T},\n    A::Vector{S},\n    b::AbstractVector{T}\n) where {T <: Real, S <: Union{AbstractSparseMatrix, AbstractMatrix}}\n\nGiven an SDP in standard form\n\nbeginaligned\n textmaximize  mathbftr(CX) \n textsubject to  mathbftr(A_iX) = b_i qquad i = 1 dots m \n X succeq 0\nendaligned\n\nbuilds and returns a Hypatia model.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.construct_matrices-Tuple{WaveOperators.IntegralEquation, Any}","page":"API reference","title":"PhysicalBounds.construct_matrices","text":"contruct_matrices(physics::IntegralEquation, P::M, Q::M) where {M <: AbstractMatrix}\n\nConstructs the matrices bar P bar Q bar A_i as in [Angeris et al. 2021] used to build the bounding semidefinite program.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.dual_problem_solve-Tuple{Any, Any, Any}","page":"API reference","title":"PhysicalBounds.dual_problem_solve","text":"dual_problem_solve(C, Av, b; optimizer=Hypatia.Optimizer(verbose=false))\n\nSolves the 'dual' SDP\n\nbeginaligned\n textminimize  b^Ty \n textsubject to  sum_i=1^m y_iA_i + C succeq 0 \nendaligned\n\nwhere the A_i's are stored in the vector Av, using the specified optimizer.\n\nReturns the model and variable y, after running the solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.heuristic_solve-Tuple{Type{LBFGS}, WaveOperators.IntegralEquation, Any}","page":"API reference","title":"PhysicalBounds.heuristic_solve","text":"function heuristic_solve(\n    ::Type{LBFGS}, \n    physics::IntegralEquation, \n    c_complex;\n    θ₀=nothing,\n    λ=0,\n    rseed=0,\n    m=20,\n    factr=1e7,\n    pgtol=1e-8,\n    iprint=1,\n    maxfun=1000,\n    maxiter=250\n)\n\nUses L-BFGS-B to solve the physical design problem\n\nbeginaligned\n textminimize -f(z) \n textsubject to  A(theta)z = b \n 0 le theta le 1\nendaligned\n\nThe equality constraint is eliminated by substituting A(theta)^-1b for z. The objective f is\n\nf(z) = fraclvert c^Tzrvertz^2 + lambdalvert c^Tzrvert\n\nNote that if we set lambda = 0, we are optimizing for 'purity', whereas if we set lambda = infty, we are optimizing for power (in a particular mode).\n\nThe solver warmstarts at θ₀. The L-BFGS-B solver has parameters  m, factr, pgtol, iprint, maxfun, and maxiter. See code for details.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.optimize!-Tuple{COSMO.Workspace}","page":"API reference","title":"PhysicalBounds.optimize!","text":"optimize!(model::COSMO.Workspace) = COSMO.optimize!(model)\n\nCalls the COSMO solver on the problem model.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.optimize-Union{Tuple{Hypatia.Models.Model{T}}, Tuple{T}} where T","page":"API reference","title":"PhysicalBounds.optimize","text":"optimize(model::Hypatia.Models.Model{T}; verbose=true) where {T}\n\nCalls the Hypatia solver on the problem model.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.primal_problem_solve-Tuple{Any, Any, Any}","page":"API reference","title":"PhysicalBounds.primal_problem_solve","text":"primal_problem_solve(C, Av, b; ineq = nothing, optimizer=Hypatia.Optimizer(verbose=false), warmstart_X=nothing)\n\nSolves the SDP\n\nbeginaligned\n textminimize  mathbftr(CX) \n textsubject to  mathbftr(A_iX) = b_i qquad i = 1 dots m \n X succeq 0\nendaligned\n\nwhere the A_i's are stored in the vector Av, using the specified optimizer.\n\nReturns the model and variable X, after running the solver.\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.to_complex","page":"API reference","title":"PhysicalBounds.to_complex","text":"to_complex(x)\n\nReturns a complex vector y corresponding to x, where x is assumed to have the form\n\n    x = beginbmatrix mathbfRe(y)  mathbfIm(y) endbmatrix\n\n\n\n\n\n","category":"function"},{"location":"api/#PhysicalBounds.to_real","page":"API reference","title":"PhysicalBounds.to_real","text":"to_real(x)\n\nConverts x to real.\n\nIf x is a Vector, returns the real and imaginary parts stacked:[real(x)ᵀ imag(x)ᵀ]ᵀ`.\n\nIf x is a matrix, returns [real(x) -imag(x) ; imag(x) real(x)]\n\n\n\n\n\n","category":"function"},{"location":"api/#PhysicalBounds.unvec_symm-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T<:Number","page":"API reference","title":"PhysicalBounds.unvec_symm","text":"unvec_symm(x, dim)\n\nReturns a dim-by-dim symmetric matrix corresponding to x. x is a vector of length dim*(dim + 1)/2, corresponding to a symmetric matrix\n\nX = [ X11  X12 ... X1k\n      X21  X22 ... X2k\n      ...\n      Xk1  Xk2 ... Xkk ],\n\nwhere vec(X) = (X11, X12, X22, X13, X23, ..., Xkk)\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.unvec_symm-Union{Tuple{Vector{T}}, Tuple{T}} where T<:Number","page":"API reference","title":"PhysicalBounds.unvec_symm","text":"unvec_symm(x)\n\nReturns a dim-by-dim symmetric matrix corresponding to vector x, where dim  is the unique positive solution to dim * (dim + 1) ÷ 2 = length(x):\n\nX = [ X11  X12 ... X1k\n      X21  X22 ... X2k\n      ...\n      Xk1  Xk2 ... Xkk ],\n\nwhere vec(X) = (X11, X12, X22, X13, X23, ..., Xkk)\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.unvec_symm_scs-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T<:Number","page":"API reference","title":"PhysicalBounds.unvec_symm_scs","text":"unvec_symm_scs(x)\n\nReturns a dim-by-dim symmetric matrix corresponding to x. x is a vector of length dim*(dim + 1)/2, corresponding to a symmetric matrix\n\nX = [ X11     X12/√2 ... X1k/√2\n      X21/√2  X22    ... X2k/√2\n      ...\n      Xk1/√2  Xk2/√2 ... Xkk ],\n\nwhere vec(X) = (X11, X12, X22, X13, X23, ..., Xkk)\n\nNote that the factor √2 preserves inner products: x'*c = Tr(unvec_symm(c, dim) * unvec_symm(x, dim))\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.vec_symm-Tuple{Any}","page":"API reference","title":"PhysicalBounds.vec_symm","text":"vec_symm(X)\n\nReturns a vectorized representation of a symmetric matrix X. vec(X) = (X11, X12, X22, X13, X23, ..., Xkk)\n\n\n\n\n\n","category":"method"},{"location":"api/#PhysicalBounds.vec_symm_scs-Tuple{Any}","page":"API reference","title":"PhysicalBounds.vec_symm_scs","text":"vec_symm_scs(X)\n\nReturns a vectorized representation of a symmetric matrix X. vec(X) = (X11, √2*X12, X22, √2*X13, X23, ..., Xkk)\n\nNote that the factor √2 preserves inner products: x'*c = Tr(unvec_symm(c, dim) * unvec_symm(x, dim))\n\n\n\n\n\n","category":"method"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"EditURL = \"https://github.com/cvxgrp/PhysicalBounds.jl/blob/main/examples/bend.jl\"","category":"page"},{"location":"examples/bend/#Bend-design","page":"Bend design","title":"Bend design","text":"","category":"section"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"We show how to compute a heuristic design for a bend.","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"# Import packages\nusing WaveOperators, PhysicalBounds, Plots\nusing Random, LinearAlgebra","category":"page"},{"location":"examples/bend/#Constructing-the-design-region","page":"Bend design","title":"Constructing the design region","text":"","category":"section"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"We first have to setup the problem data. For a more detailed walkthrough of this section, checkout the corresponding example in WaveOperators.jl.","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"n = 40                                  # Number of gridpoints per unit length\nwidth, height = 2, 2                    # Width and height of the domain\nk = 2π                                  # Wavenumber of the domain\ng = Grid(height, width, 1/n, k)\n\n# ----- Defining things inside of the grid -----\n# Add the waveguide slab, centered, of width height/3\ncontrast = 5\nwg_width = height/6\n\n# Add horizontal waveguide\nmidpoint_h, midpoint_w = height/2, width/2\ninput_waveguide = Rectangle((midpoint_h - wg_width/2, 0), (wg_width, width/2))\nset_contrast!(g, input_waveguide, contrast)\n\n# Add vertical waveguide\noutput_waveguide = Rectangle((0, width/2-wg_width/2), (midpoint_h+wg_width/2, wg_width))\nset_contrast!(g, output_waveguide, contrast)\n\n# Add design region\nside_length = height/4\ndesign_region = Rectangle((height/2 - side_length/2, width/2 - side_length/2), (side_length, side_length))\ndesignidx = getindices(g, design_region)\nset_contrast!(g, design_region, contrast)\nheatmap(\n    repeat(g.contrast, inner=(8,8)),\n    interpolate=true,\n    title=\"Design Region\",\n    dpi=300,\n    xaxis=nothing,\n    yaxis=nothing\n)","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"Now, we add an input field","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"# Input mode\ninput_mode_line = VerticalLine(0.0)\nadd_mode!(g, input_mode_line, 1)\n\n# Output mode\noutput_mode_line = HorizontalLine(0.0)\noutput_mode = @. sqrt(1 + g.contrast[end, :]) * compute_modes(g, output_mode_line).vectors[:, 2]\n\ng_functions = generate_G(g, design_region, output_mode_line)\n@. g_functions.b_target *= sqrt(1 + g.contrast[end, :])\ng_functions.G_target .= Diagonal(@. sqrt(1 + g.contrast[end, :])) * g_functions.G_target;\nnothing #hide","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"We can visualize this initial field. We interpolate for a nicer plot.","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"using Interpolations: LinearInterpolation\nfunction interpolate(img; factor=8, ylims=(0,2), xlims=(0,2))\n    xx = range(xlims..., size(img, 1))\n    yy = range(ylims..., size(img, 2))\n    itp = LinearInterpolation((xx,yy), img)\n    x2 = range(xlims..., size(img, 1)*factor)\n    y2 = range(ylims..., size(img, 2)*factor)\n    return [itp(x, y) for x in x2, y in y2]\nend\n\nsol_initial = WaveOperators.solve(g)\nfield_plt = heatmap(\n    interpolate(\n        Matrix(abs.(sol_initial)) / maximum(abs.(sol_initial));\n        xlims=(0, width),\n        ylims=(0, height)\n    ),\n    dpi=300,\n    title=\"Initial Field\",\n    xaxis=nothing,\n    yaxis=nothing,\n)","category":"page"},{"location":"examples/bend/#Heuristic-design","page":"Bend design","title":"Heuristic design","text":"","category":"section"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"We compute a heuristic design using LBFGSB","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"Random.seed!(0)\nθ₀ = rand((0.0,1.0), length(designidx))\nfstar, θstar = heuristic_solve(LBFGS, g_functions, output_mode; θ₀, λ=Inf, factr=1e11, maxiter=500, maxfun=1000, iprint=0)\n\ndesign = deepcopy(g)\ndesign.contrast[designidx] .*= θstar\nsol_design = WaveOperators.solve(design)\n\ndesign_plt = heatmap(\n    repeat(design.contrast, inner=(8,8)),\n    title=\"Optimal Design\",\n    dpi=300,\n    xaxis=nothing,\n    yaxis=nothing\n)\n\nfield_plt = heatmap(\n    interpolate(\n        Matrix(abs.(sol_design)) / maximum(abs.(sol_design));\n        xlims=(0, width),\n        ylims=(0, height)\n    ),\n    dpi=300,\n    title=\"Realized Field\",\n    xaxis=nothing,\n    yaxis=nothing,\n)","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"","category":"page"},{"location":"examples/bend/","page":"Bend design","title":"Bend design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"EditURL = \"https://github.com/cvxgrp/PhysicalBounds.jl/blob/main/examples/mode-converter.jl\"","category":"page"},{"location":"examples/mode-converter/#Mode-converter-bounds-and-design","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"","category":"section"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"We show how to compute bounds and a heuristic design for a mode converter. This example is similar to that in the numerical experiments section of Bounds on Efficiency Metrics in Photonics. For the exact code used in the paper, please see the paper folder of the Github repo.","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"# Import packages\nusing Plots\nusing Random, LinearAlgebra\nusing PhysicalBounds, WaveOperators\nusing JuMP, SCS","category":"page"},{"location":"examples/mode-converter/#Constructing-the-design-region","page":"Mode converter bounds and design","title":"Constructing the design region","text":"","category":"section"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"We first have to setup the problem data. For a more detailed walkthrough of this section, checkout the corresponding example in WaveOperators.jl.","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"Note that the number of grid points n in this example is very low so that it can efficienctly run during CI. Basic parameters. n is the number of gridpoints per unit length","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"n = 15                                  # Number of gridpoints per unit length\nwidth, height = 2, 1                    # Width and height of the domain\nk = 2π                                  # Wavenumber of the domain\ng = Grid(height, width, 1/n, k)\n\n# ----- Defining things inside of the grid -----\n# Add the waveguide slab, centered, of width height/3\ncontrast = 5\nwaveguide = Slab(height/2, height/3)\nset_contrast!(g, waveguide, contrast)\n\n# Compute the input mode and add it as an input to the grid\nmode_input_position = 0\nmode_number = 1\ninput_line = VerticalLine(mode_input_position)\nmode = add_mode!(g, input_line, mode_number)\n\n# Add the design, centered on the domain, of size d_height, d_width\n# Make the max possible contrast = `contrast`\nd_height = 2*height/3\nd_width = width/2\nx_pos = height/2 - d_height/2\ny_pos = width/2 - d_width/2\n\ndesign_region = Rectangle((x_pos, y_pos), (d_height, d_width))\ndesignidx = getindices(g, design_region)\nset_contrast!(g, design_region, contrast)\n\n\n# ---- Defining the objective -----\n# Make a target line at the right hand side of the domain\ntarget_line = VerticalLine(width)\n\n# Generate the Green's function for the problem\ng_functions = generate_G(g, design_region, target_line)\nmodes = compute_modes(g, target_line)\noutput_mode = 2\nc = @. sqrt(1 + g.contrast[:,end]) * modes.vectors[:, output_mode]\nc ./= norm(c);\nnothing #hide","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"We can visualize the design region and the initial field (without a design).","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"deisgnidx = getindices(g, design_region)\nheatmap(g.contrast, title=\"Design Region\")\nsol_initial = WaveOperators.solve(g)\nplt_input = heatmap(abs.(sol_initial), title=\"Initial Field\")","category":"page"},{"location":"examples/mode-converter/#Heuristic-deign","page":"Mode converter bounds and design","title":"Heuristic deign","text":"","category":"section"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"First, we use LBFGS-B to find a heuristic design","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"# Heuristic solve via LBFGS\nRandom.seed!(0)\nθ₀ = rand(length(designidx))\nfstar, θstar = heuristic_solve(LBFGS, g_functions, c;\n    θ₀=θ₀, factr=1e11, maxiter=500, maxfun=1000, iprint=0)\ndesign = deepcopy(g)\ndesign.contrast[designidx] .*= θstar\nheatmap(design.contrast, title=\"Heuristic Design\")","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"We can visualize the resulting field. Note that by only optimizing for purity, we end up with significantly reduced power at the output.","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"sol_design = WaveOperators.solve(design)\nheatmap(abs.(sol_design), title=\"Final Field\")","category":"page"},{"location":"examples/mode-converter/#Bound-computed-using-an-SDP","page":"Mode converter bounds and design","title":"Bound computed using an SDP","text":"","category":"section"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"We compare the mode purity of our design to the upper bound.","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"P, Q, A = PhysicalBounds.construct_matrices(g_functions, c)\nAv = vcat(A, [Q])\nb = vcat(zeros(length(A)), [1.0])\nineq = vcat(trues(length(A)), [false])\nmodel, X = PhysicalBounds.primal_problem_solve(-P, Av, b; ineq, optimizer=SCS.Optimizer())\npurity_bound = -objective_value(model)\npurity = abs(c'*sol_design[:, end])^2 / norm(sol_design[:, end])^2\nprintln(\"Purtity = $purity\")\nprintln(\"Purity bound = $purity_bound\")","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"We see that our heuristic design is quite close to the upper bound.","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"","category":"page"},{"location":"examples/mode-converter/","page":"Mode converter bounds and design","title":"Mode converter bounds and design","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PhysicalBounds   ","category":"page"},{"location":"#PhysicalBounds","page":"Home","title":"PhysicalBounds","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package contains code to compute bounds on physical devices that are governed by the Helmhotlz equation[1]. To get started, check out the examples!","category":"page"},{"location":"","page":"Home","title":"Home","text":"The figures in Bounds on Efficiency Metrics in Photonics can be reproduced with code in the paper folder of the repository.","category":"page"},{"location":"#Examples:","page":"Home","title":"Examples:","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"examples/bend.md\", \"examples/lens.md\", \"examples/mode-converter.md\"]\nDepth = 1","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Angeris, G., Diamandis, T., Vučković, J., & Boyd, S. (2022). Bounds on Efficiency Metrics in Photonics. arXiv preprint arXiv:2204.05243.","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"The source files for all examples can be found in /examples.","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"EditURL = \"https://github.com/cvxgrp/PhysicalBounds.jl/blob/main/examples/lens.jl\"","category":"page"},{"location":"examples/lens/#Lens-bounds-and-design","page":"Lens bounds and design","title":"Lens bounds and design","text":"","category":"section"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"We show how to compute bounds and a heuristic design for a lens.","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"# Import packages\nusing Plots\nusing Random, LinearAlgebra\nusing PhysicalBounds, WaveOperators\nusing JuMP, SCS","category":"page"},{"location":"examples/lens/#Constructing-the-design-region","page":"Lens bounds and design","title":"Constructing the design region","text":"","category":"section"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"We first have to setup the problem data. For a more detailed walkthrough of this section, checkout the corresponding example in WaveOperators.jl.","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"Note that the number of grid points n in this example is very low so that it can efficienctly run during CI.","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"n = 15                                  # Number of gridpoints per unit length\nwidth, height = 2, 1                    # Width and height of the domain\nk = 2π                                  # Wavenumber of the domain\ng = Grid(height, width, 1/n, k)\n\n# ----- Defining things inside of the grid -----\n# Add the waveguide slab, centered, of width height/3\ncontrast = 5\nd_height = 2*height/3\nslab = Slab(height/2, d_height)\n\n# Compute the input add it as a current to the grid\ninput_position = 0.0\ninput_line = ShapeSlice(slab, VerticalLine(input_position))\nadd_current!(g, input_line, 1)\n\n# Add the design, centered on the domain, of size d_height, d_width\n# Make the max possible contrast = `contrast`\nd_width = width/4\nx_pos = height/2 - d_height/2\ny_pos = width/2 - d_width/2\n\ndesign_region = Rectangle((x_pos, y_pos), (d_height, d_width))\nset_contrast!(g, design_region, contrast)\n\n\n# ---- Defining the objective -----\n# Make a target line at the right hand side of the domain\nfocal_plane = VerticalLine(width)\nfocus_slab = Slab(height/2, height/3)\nfocal_spot = ShapeSlice(slab, focal_plane)\n\nfocal_spot_idx_set = Set(getindices(g, focal_spot))\nfocal_spot_idx = findall(idx -> idx in focal_spot_idx_set, getindices(g, focal_plane))\n\n# Generate the Green's function for the problem\ng_functions = generate_G(g, design_region, focal_plane);\nnothing #hide","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"We can visualize the design region and the initial field (without a design).","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"designidx = getindices(g, design_region)\nheatmap(g.contrast, title=\"Design Region\")\nsol_initial = WaveOperators.solve(g)\nplt_input = heatmap(abs.(sol_initial), title=\"Initial Field\")","category":"page"},{"location":"examples/lens/#Heuristic-design","page":"Lens bounds and design","title":"Heuristic design","text":"","category":"section"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"First, we use LBFGS-B to find a heuristic design","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"Random.seed!(0)\nθ₀ = zeros(length(designidx))\nfstar, θstar = heuristic_solve(LBFGS, g_functions, focal_spot_idx;\n    θ₀, factr=0, maxiter=1000, maxfun=1000, iprint=0)\ndesign = deepcopy(g)\ndesign.contrast[designidx] .*= θstar\nheatmap(design.contrast, title=\"Heuristic Design\")","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"We can visualize the resulting field.","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"sol_design = WaveOperators.solve(design)\nheatmap(abs.(sol_design), title=\"Final Field\")","category":"page"},{"location":"examples/lens/#Bound-computed-using-an-SDP","page":"Lens bounds and design","title":"Bound computed using an SDP","text":"","category":"section"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"We compare the efficiency of our design to the upper bound.","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"P, Q, A = PhysicalBounds.construct_matrices(g_functions, focal_spot_idx)\nAv = vcat(A, [Q])\nb = vcat(zeros(length(A)), [1.0])\nineq = vcat(trues(length(A)), [false])\nmodel, X = PhysicalBounds.primal_problem_solve(-P, Av, b; ineq, optimizer=SCS.Optimizer())\npurity_bound = -objective_value(model)\neff = sum(abs.(sol_design[:, end][focal_spot_idx]).^2) / norm(sol_design[:, end])^2\nprintln(\"Focusing efficiency: $eff\")\nprintln(\"Efficiency bound = $purity_bound\")","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"We see that our heuristic design is quite close to the upper bound.","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"","category":"page"},{"location":"examples/lens/","page":"Lens bounds and design","title":"Lens bounds and design","text":"This page was generated using Literate.jl.","category":"page"}]
}
